From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Igor Pecovnik <igor.pecovnik@****l.com>
Date: Sun, 30 Jul 2023 09:16:55 +0000
Subject: Patching kernel rockchip64 files sound/soc/codecs/Kconfig
 sound/soc/codecs/Makefile sound/soc/codecs/i2s_clock_board.c

Signed-off-by: Igor Pecovnik <igor.pecovnik@****l.com>
---
 sound/soc/codecs/Kconfig           |   3 +
 sound/soc/codecs/Makefile          |   2 +
 sound/soc/codecs/i2s_clock_board.c | 269 ++++++++++
 3 files changed, 274 insertions(+)

diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 71c2e4b3a8cc..9e29dde6b8ae 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -1189,10 +1189,13 @@ config SND_SOC_PCM3168A_SPI
 	select REGMAP_SPI
 
 config SND_SOC_PCM5102A
 	tristate "Texas Instruments PCM5102A CODEC"
 
+config SND_SOC_I2S_CLOCK_BOARD
+	tristate "Simple I2S clock board"
+
 config SND_SOC_PCM512x
 	tristate
 
 config SND_SOC_PCM512x_I2C
 	tristate "Texas Instruments PCM512x CODECs - I2C"
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 3d76b754eb4f..97c2ed6c1fe7 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -178,10 +178,11 @@ snd-soc-pcm3060-i2c-objs := pcm3060-i2c.o
 snd-soc-pcm3060-spi-objs := pcm3060-spi.o
 snd-soc-pcm3168a-objs := pcm3168a.o
 snd-soc-pcm3168a-i2c-objs := pcm3168a-i2c.o
 snd-soc-pcm3168a-spi-objs := pcm3168a-spi.o
 snd-soc-pcm5102a-objs := pcm5102a.o
+snd-soc-i2s_clock_board-objs := i2s_clock_board.o
 snd-soc-pcm512x-objs := pcm512x.o
 snd-soc-pcm512x-i2c-objs := pcm512x-i2c.o
 snd-soc-pcm512x-spi-objs := pcm512x-spi.o
 snd-soc-rk3308-objs := rk3308_codec.o
 snd-soc-rk3328-objs := rk3328_codec.o
@@ -535,10 +536,11 @@ obj-$(CONFIG_SND_SOC_PCM3060_I2C)	+= snd-soc-pcm3060-i2c.o
 obj-$(CONFIG_SND_SOC_PCM3060_SPI)	+= snd-soc-pcm3060-spi.o
 obj-$(CONFIG_SND_SOC_PCM3168A)	+= snd-soc-pcm3168a.o
 obj-$(CONFIG_SND_SOC_PCM3168A_I2C)	+= snd-soc-pcm3168a-i2c.o
 obj-$(CONFIG_SND_SOC_PCM3168A_SPI)	+= snd-soc-pcm3168a-spi.o
 obj-$(CONFIG_SND_SOC_PCM5102A)	+= snd-soc-pcm5102a.o
+obj-$(CONFIG_SND_SOC_I2S_CLOCK_BOARD)	+= snd-soc-i2s_clock_board.o
 obj-$(CONFIG_SND_SOC_PCM512x)	+= snd-soc-pcm512x.o
 obj-$(CONFIG_SND_SOC_PCM512x_I2C)	+= snd-soc-pcm512x-i2c.o
 obj-$(CONFIG_SND_SOC_PCM512x_SPI)	+= snd-soc-pcm512x-spi.o
 obj-$(CONFIG_SND_SOC_RK3308)	+= snd-soc-rk3308.o
 obj-$(CONFIG_SND_SOC_RK3328)	+= snd-soc-rk3328.o
diff --git a/sound/soc/codecs/i2s_clock_board.c b/sound/soc/codecs/i2s_clock_board.c
new file mode 100644
index 000000000000..6577a148cba9
--- /dev/null
+++ b/sound/soc/codecs/i2s_clock_board.c
@@ -0,0 +1,269 @@
+/*
+ * Driver for clocks board for i2s bus
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-component.h>
+
+#if (1)
+#define DBGOUT(msg...)		do { printk(msg); } while (0)
+#else
+#define DBGOUT(msg...)		do {} while (0)
+#endif
+
+
+struct i2s_clock_board_priv {
+    struct device *dev;
+    // child of clkin
+    struct clk *i2s_clk;
+    // clkin
+    struct clk *i2s_pclk;
+    // master clock ration
+    unsigned long mclk_fs;
+};
+
+static int i2s_clock_board_soc_probe(struct snd_soc_component *component)
+{
+    DBGOUT("i2s_clock_board: %s\n", __func__);
+    return 0;
+}
+
+static void i2s_clock_board_soc_remove(struct snd_soc_component *component)
+{
+    DBGOUT("i2s_clock_board: %s\n", __func__);
+}
+
+static int i2s_clock_board_soc_suspend(struct snd_soc_component *component)
+{
+    DBGOUT("i2s_clock_board: %s\n", __func__);
+    return 0;
+}
+
+static int i2s_clock_board_soc_resume(struct snd_soc_component *component)
+{
+    DBGOUT("i2s_clock_board: %s\n", __func__);
+    return 0;
+}
+
+static const struct snd_soc_component_driver soc_codec_i2s_clock_board = {
+    .probe = i2s_clock_board_soc_probe,
+    .remove = i2s_clock_board_soc_remove,
+    .suspend = i2s_clock_board_soc_suspend,
+    .resume = i2s_clock_board_soc_resume,
+};
+
+static int i2s_clock_board_set_dai_fmt(struct snd_soc_dai *codec_dai,
+        unsigned int format)
+{
+    DBGOUT("i2s_clock_board: %s\n", __func__);
+    return 0;
+}
+
+
+static int set_clock(struct i2s_clock_board_priv *priv, unsigned long rate)
+{
+    int ret;
+    DBGOUT("i2s_clock_board: set_clock: %lu\n", rate);
+    ret = clk_set_rate(priv->i2s_pclk, rate);
+    if(ret)
+        dev_err(priv->dev, "clk_set_rate %lu error\n", rate);
+    else
+        DBGOUT("i2s_clock_board: %s clk_set_rate %lu OK\n", __func__, rate);
+
+    ret = clk_set_parent(priv->i2s_clk, priv->i2s_pclk);
+    if(ret)
+        dev_err(priv->dev, "clk_set_parent error\n");
+    else
+        DBGOUT("i2s_clock_board: %s clk_set_parent OK\n", __func__);
+
+    return ret;
+}
+
+
+static int i2s_clock_board_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params,
+    struct snd_soc_dai *dai)
+{
+    unsigned long rate = params_rate(params);
+    unsigned long mclk;
+    struct snd_soc_component *component = dai->component;
+    struct i2s_clock_board_priv *priv = snd_soc_component_get_drvdata(component);
+    DBGOUT("i2s_clock_board: %s, physical_width=%d, rate=%d, width=%d\n", __func__, (int)params_physical_width(params), (int)rate, (int)params_width(params));
+
+    switch(rate)
+    {
+        case 44100:
+        case 88200:
+        case 176400:
+            mclk = priv->mclk_fs * 44100;
+            break;
+        case 48000:
+        case 96000:
+        case 192000:
+        case 384000:
+            mclk = priv->mclk_fs * 48000;
+            break;
+    }
+
+    return set_clock(priv, mclk);
+}
+
+static int i2s_clock_board_trigger(struct snd_pcm_substream *substream, int cmd,
+             struct snd_soc_dai *dai)
+{
+    struct snd_soc_component *component = dai->component;
+
+    switch (cmd) {
+        case SNDRV_PCM_TRIGGER_START:
+        case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+        case SNDRV_PCM_TRIGGER_RESUME:
+            DBGOUT("i2s_clock_board: %s, component %s start\n", __func__, component->name);
+            if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+            }
+            else {
+            }
+        break;
+
+        case SNDRV_PCM_TRIGGER_STOP:
+        case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+        case SNDRV_PCM_TRIGGER_SUSPEND:
+            DBGOUT("i2s_clock_board: %s, component %s stop\n", __func__, component->name);
+            if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+            }
+            else {
+            }
+        break;
+
+        default:
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+static const struct snd_soc_dai_ops i2s_clock_board_dai_ops = {
+    .set_fmt    = i2s_clock_board_set_dai_fmt,
+    .hw_params  = i2s_clock_board_hw_params,
+    .trigger    = i2s_clock_board_trigger,
+};
+
+#define SNDRV_PCM_RATE_44100_192000 (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | \
+        SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | \
+        SNDRV_PCM_RATE_192000)
+
+static struct snd_soc_dai_driver i2s_clock_board_dai = {
+    .name               = "i2s_clock_board",
+    .playback = {
+        .stream_name    = "Playback",
+        .channels_min   = 2,
+        .channels_max   = 2,
+        .rates          = SNDRV_PCM_RATE_44100_192000 | SNDRV_PCM_RATE_KNOT,
+        .rate_min       = 44100,
+        .rate_max       = 384000,
+        .formats        = SNDRV_PCM_FMTBIT_S24_LE,
+    },
+    .capture = {
+        .stream_name    = "Capture",
+        .channels_min   = 2,
+        .channels_max   = 2,
+        .rates          = SNDRV_PCM_RATE_44100_192000,
+        .formats        = SNDRV_PCM_FMTBIT_S24_LE,
+    },
+    .ops                = &i2s_clock_board_dai_ops,
+};
+
+static const struct of_device_id i2s_clock_board_dt_ids[] = {
+    { .compatible = "custom,i2s_clock_board", },
+    { }
+};
+MODULE_DEVICE_TABLE(of, i2s_clock_board_dt_ids);
+
+static int i2s_clock_board_probe(struct platform_device *pdev)
+{
+    struct device *dev = &pdev->dev;
+    struct i2s_clock_board_priv *priv;
+    u32 mclk_fs;
+    struct clk *i2s_clk;
+
+    DBGOUT("i2s_clock_board: %s\n", __func__);
+    priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+    if (!priv)
+        return -ENOMEM;
+
+    dev_set_drvdata(dev, priv);
+    priv->dev = &pdev->dev;
+
+    i2s_clk = devm_clk_get(&pdev->dev, "i2s_clk");
+    if (IS_ERR(i2s_clk)) {
+        dev_err(&pdev->dev, "Can't retrieve i2s clock\n");
+        return PTR_ERR(i2s_clk);
+    }
+    else
+        DBGOUT("i2s_clock_board: %s get_clock %s OK\n", __func__, "i2s_clk");
+
+    priv->i2s_clk = clk_get_parent(i2s_clk);
+    if (IS_ERR(priv->i2s_clk)) {
+        dev_err(&pdev->dev, "Can't retrieve parent of i2s clock\n");
+        return PTR_ERR(priv->i2s_clk);
+    }
+    else
+        DBGOUT("i2s_clock_board: %s clk_get_parent OK\n", __func__);
+
+    priv->i2s_pclk = devm_clk_get(&pdev->dev, "i2s_pclk");
+    if (IS_ERR(priv->i2s_pclk)) {
+        dev_err(&pdev->dev, "Can't retrieve external i2s clock\n");
+        return PTR_ERR(priv->i2s_pclk);
+    }
+    else
+        DBGOUT("i2s_clock_board: %s get_clock %s OK\n", __func__, "i2s_pclk");
+
+    if(of_property_read_u32(pdev->dev.of_node, "mclk-fs", &mclk_fs) == 0)
+        DBGOUT("i2s_clock_board: %s read mclk-fs %u OK\n", __func__, mclk_fs);
+    else
+    {
+        DBGOUT("i2s_clock_board: %s read mclk-fs ERROR set to default value 256\n", __func__);
+        mclk_fs = 256;
+    }
+    priv->mclk_fs = mclk_fs;
+
+    return snd_soc_register_component(dev, &soc_codec_i2s_clock_board,
+      &i2s_clock_board_dai, 1);
+}
+
+static int i2s_clock_board_remove(struct platform_device *pdev)
+{
+    snd_soc_unregister_component(&pdev->dev);
+    return 0;
+}
+
+static struct platform_driver i2s_clock_board_driver = {
+    .probe              = i2s_clock_board_probe,
+    .remove             = i2s_clock_board_remove,
+    .driver             = {
+        .name           = "i2s_clock_board",
+        .of_match_table = of_match_ptr(i2s_clock_board_dt_ids),
+    },
+};
+
+module_platform_driver(i2s_clock_board_driver);
+
+MODULE_DESCRIPTION("ASoC external clock board for I2S bus");
+MODULE_LICENSE("GPL v2");
\ No newline at end of file
-- 
Created with Armbian build tools https://github.com/armbian/build

